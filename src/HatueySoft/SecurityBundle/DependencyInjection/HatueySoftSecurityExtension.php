<?php


namespace HatueySoft\SecurityBundle\DependencyInjection;

use Symfony\Component\DependencyInjection\ContainerBuilder;
use Symfony\Component\Config\FileLocator;
use Symfony\Component\HttpKernel\DependencyInjection\Extension;
use Symfony\Component\DependencyInjection\Loader;

/**
 * This is the class that loads and manages your bundle configuration
 *
 * To learn more see {@link http://symfony.com/doc/current/cookbook/bundles/extension.html}
 */
class HatueySoftSecurityExtension extends Extension
{
    private $defaultIcon = 'question-sign';

    private $defaultRulesCodes = array('delete', 'edit', 'new', 'search', 'show', 'list');

    /**
     * Provides the default rules defined by HatueySecurity.
     * This allows to provide some nice defaults for backends that don't
     * define their own rules.
     */
    private $defaultRulesProperties = array(
        'create' => array('code' => 'create', 'label' => 'Crear', 'icon' => 'plus'),
        'edit' => array('code' => 'edit', 'label' => 'Editar', 'icon' => 'pencil'),
        'view' => array('code' => 'view', 'label' => 'Mostrar', 'icon' => 'eye-open'),
        'delete' => array('code' => 'delete', 'label' => 'Eliminar', 'icon' => 'trash'),
        'list' => array('code' => 'list', 'label' => 'Listar', 'icon' => 'list'),
        'search' => array('code' => 'search', 'label' => 'Buscar', 'icon' => 'search'),
    );

    public function load(array $configs, ContainerBuilder $container)
    {
        // process bundle's configuration parameters
        $backendConfiguration = $this->processConfiguration(new Configuration(), $configs);

        $mappings = $backendConfiguration['security_config'];
        $scope = $backendConfiguration['command_scope'];
        $configFile = $backendConfiguration['config_file'];
        $container->setParameter('security_config', $mappings);
        $container->setParameter('command_scope', $scope);
        $container->setParameter('config_file', $configFile);

        //primer paso, tomar la configuración de las entidades, permitiendo varias formas
        $backendConfiguration['acl']['entities'] = $this->getEntitiesConfiguration($backendConfiguration['acl']['entities']);

        //último paso, trasformar la configuración leida en el YAML en una a gusto nuestro
        $backendConfiguration = $this->transformEntityConfig($backendConfiguration);

        $container->setParameter('hatuey_soft_security.config', $backendConfiguration);

        // load bundle's services
        $loader = new Loader\YamlFileLoader($container, new FileLocator(__DIR__ . '/../Resources/config'));
        $loader->load('services.yml');
        $loader->load('listener.yml');

    }

    /**
     * Processes, normalizes and initializes the configuration of the entities
     * that are managed by the backend. Several configuration formats are allowed,
     * so this method normalizes them all.
     *
     * @param array $entitiesConfiguration
     *
     * @return array The full entity configuration
     */
    public function getEntitiesConfiguration(array $entitiesConfiguration)
    {
        if (0 === count($entitiesConfiguration)) {
            return $entitiesConfiguration;
        }

        //normaliza la configuración de entidad para permitir varios formatos
        $configuration = $this->normalizeEntitiesConfiguration($entitiesConfiguration);

        //normaliza las reglas de cada entidad y transforma esta configuracion a gusto nuestro
        $configuration = $this->processEntitiesConfiguration($configuration);

        return $configuration;
    }

    /**
     * Transforms the two simple configuration formats into the full expanded
     * configuration. This allows to reuse the same method to process any of the
     * different configuration formats.
     *
     * These are the two simple formats allowed:
     *
     * # Config format #1: no custom entity label
     * hatuey_soft_security:
     *   acl:
     *     entities:
     *         - AppBundle\Entity\User
     *
     * # Config format #2: simple config with custom entity label
     * hatuey_soft_security:
     *   acl:
     *     entities:
     *         User: AppBundle\Entity\User
     *
     * And this is the full expanded configuration syntax generated by this method:
     *
     * # Config format #3: expanded entity configuration with 'class' parameter
     * hatuey_soft_security:
     *   acl:
     *     entities:
     *         User:
     *             class: AppBundle\Entity\User
     *
     * # Config format #3 can optionally define a custom entity label
     * hatuey_soft_security:
     *   acl:
     *     entities:
     *         User:
     *             class: AppBundle\Entity\User
     *             label: 'Clients'
     *
     * @param array $entitiesConfiguration The entity configuration in one of the simplified formats
     *
     * @return array The normalized configuration
     */
    private function normalizeEntitiesConfiguration(array $entitiesConfiguration)
    {
        $normalizedConfiguration = array();

        foreach ($entitiesConfiguration as $entityLabel => $entityConfiguration) {
            // config formats #1 and #2
            if (!is_array($entityConfiguration)) {
                $entityConfiguration = array('class' => $entityConfiguration);
            }

            // if config format #3 is used, ensure that it defines the 'class' option
            if (!isset($entityConfiguration['class'])) {
                throw new \RuntimeException(sprintf('The "%s" entity must define its associated Doctrine entity class using the "class" option.',
                    $entityLabel));
            }

            $entityClassParts = explode('\\', $entityConfiguration['class']);
            $entityClassName = end($entityClassParts);

            // if config format #3 defines the 'label' option, use its value.
            // otherwise, infer the entity label from its configuration.
            if (!isset($entityConfiguration['label'])) {
                // config format #1 doesn't define any entity label because configuration is
                // just a plain numeric array (the label is the integer key of that array).
                // In that case, use the entity class name as its label
                $entityConfiguration['label'] = is_integer($entityLabel) ? $entityClassName : $entityLabel;
            }

            $entityName = $this->getUniqueEntityName($entityClassName, array_keys($normalizedConfiguration));
            $entityConfiguration['name'] = $entityName;

            $normalizedConfiguration[$entityName] = $entityConfiguration;
        }

        return $normalizedConfiguration;
    }

    /**
     * The name of the entity is included in the URLs of the backend to define
     * the entity used to perform the operations. Obviously, the entity name
     * must be unique to identify entities unequivocally.
     *
     * This method ensures that the given entity name is unique among all the
     * previously existing entities passed as the second argument. This is
     * achieved by iteratively appending a suffix until the entity name is
     * guaranteed to be unique.
     *
     * @param string $entityName
     * @param array $existingEntityNames
     *
     * @return string The entity name transformed to be unique
     */
    private function getUniqueEntityName($entityName, array $existingEntityNames)
    {
        $uniqueName = $entityName;

        while (in_array($uniqueName, $existingEntityNames)) {
            $uniqueName .= '_';
        }

        return $uniqueName;
    }

    /**
     * Normalizes and initializes the configuration of the given entities to
     * simplify the option processing of the other methods and functions.
     *
     * @param array $entitiesConfiguration
     *
     * @return array The configured entities
     */
    private function processEntitiesConfiguration(array $entitiesConfiguration)
    {
        $entities = array();

        foreach ($entitiesConfiguration as $entityName => $entityConfiguration) {
            // copy the original entity configuration to not lose any of its options
            $config = $entityConfiguration;

            // if needed, initialize options to simplify further configuration processing
            if (!isset($config['rules'])) {
                //si no establece regla ninguna, ponemos todas las reglas estandard a esta entidad
                $config['rules'] = array_values($this->defaultRulesProperties);
            } else {
                //Normalizes and initializes the rules of the given entity
                $config['rules'] = $this->normalizeRulesConfiguration($config['rules'], $entityConfiguration);
            }
            $entities[$entityName] = $config;
        }

        return $entities;
    }

    /**
     *
     * @param array $backendConfiguration
     *
     * @return array
     */
    public function transformEntityConfig(array $backendConfiguration)
    {
        $entitiesConfiguration = array();

        //transformar el $backendConfiguration en  $entityConfiguration
        foreach ($backendConfiguration['acl']['entities'] as $entityName => $entityConfiguration) {
            //estoy creando esto
            $entitiesConfiguration[$entityName] = $entityConfiguration;
        }

        //estoy devolviendo esto finalmente
        $backendConfiguration['entities'] = $entitiesConfiguration;

        return $backendConfiguration;
    }

    /**
     * Entities can define their rules using two different formats:
     *
     * # Config format #1: simple configuration
     * hatuey_soft_security:
     *   acl:
     *     entities:
     *         Client:
     *           # ...
     *           rules: ['search', 'view', 'list']
     *
     * # Config format #2: extended configuration
     * hatuey_soft_security:
     *   acl:
     *     entities:
     *         User:
     *           # ...
     *           rules: ['list', 'search', { code: 'process', label: 'Procesar', icon: 'eye-open' }]
     *
     * This method processes both formats to produce a common rules configuration
     * format used in the rest of the application.
     *
     * @param array $rulesConfiguration
     * @param array $entityConfiguration The full configuration of the entity this rule belongs to
     *
     * @return array The configured entity rules
     */
    private function normalizeRulesConfiguration(array $rulesConfiguration, array $entityConfiguration = array())
    {
        $defaultRules = $this->defaultRulesProperties;

        $defaultRulesValues = array_values($this->defaultRulesProperties);

        //array of rules to return
        $rules = array();

        if (!(count($rulesConfiguration) > 0)) {
            return $defaultRulesValues;
        }

        $tieneStandard = false;
        $bandTotalNegation = false;

        foreach ($rulesConfiguration as $rule) {
            //esto quiere decir que no hay reglas definidas, por tanto hay que ponerlas todas por defecto
            if (!count($rule)) {
                return $defaultRulesValues;
            }

            if (!is_string($rule) && !is_array($rule)) {
                throw new \RuntimeException(sprintf('The values of the "rules" option of the "%s" entity can only be strings or arrays.',
                    $entityConfiguration['class']));
            }

            if (is_string($rule)) {
                // Config format #1: field is just a string representing the entity property
                $ruleConfiguration = array('code' => $rule);
            } else {
                // Config format #1: rule is an array that defines one or more
                // options. check that the mandatory 'code' option is set
                if (!array_key_exists('code', $rule)) {
                    throw new \RuntimeException(sprintf('One of the values of the "rules" of the "%s" entity does not define the "code" option.',
                        $entityConfiguration['class']));
                }
                $ruleConfiguration = $rule;
            }

            $ruleName = $ruleConfiguration['code'];

            if ((strpos($ruleName, '!') === 0) && (strlen($ruleName) === 1)) {
                //caso de que de no se quiera ninguna regla standard
                $bandTotalNegation = true;
            }

            //setear los valores por defecto
            //aqui ver si es una regla estandard o extra
            if (in_array($ruleName, $this->defaultRulesCodes)) {
                $tieneStandard = true;
                //entonces es estandard, si el usuario definio un label o un icon se le mantiene pero
                //sino se pone el por defecto
                if (!isset($ruleConfiguration['label'])) {
                    $ruleConfiguration['label'] = $defaultRules[$ruleName]['label'];
                }
                if (!isset($ruleConfiguration['icon'])) {
                    $ruleConfiguration['icon'] = $defaultRules[$ruleName]['icon'];
                }
            } else {
                //entonces es extra y como no tiene nada definido aparte del codigo
                if (!isset($ruleConfiguration['label'])) {
                    // copied from Symfony\Component\Form\FormRenderer::humanize() (author: Bernhard Schussek <bschussek@gmail.com>)
                    $label = ucfirst(trim(strtolower(preg_replace(array('/([A-Z])/', '/[_\s]+/'), array('_$1', ' '),
                        $ruleConfiguration['code']))));
                    $ruleConfiguration['label'] = $label;
                }
                if (!isset($ruleConfiguration['icon'])) {
                    $ruleConfiguration['icon'] = $this->defaultIcon;  // 'question-sign';
                }
            }

            // 'code' value is used as the class method name or the Symfony route name
            // check that its value complies with the PHP method name regexp (the leading dash
            // is exceptionally allowed to support the configuration format of removed actions)
            if (!preg_match('/^[a-zA-Z\!\-_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*$/', $ruleName, $matchActionName)) {
                throw new \InvalidArgumentException(sprintf('The name of the "%s" rule contains invalid characters (allowed: letters, numbers, underscores).',
                    $ruleName));
            }

            //$rules[$ruleName] = $ruleConfiguration;
            $rules[] = $ruleConfiguration;

        }

        if (!$tieneStandard && !$bandTotalNegation) {
            //le agrego todas las reglas estandard
            $rules = array_merge($defaultRulesValues, $rules);
        }

        //quito las reglas de negacion !
        $rules = $this->filterRemovedActions($rules, $bandTotalNegation);

        return $rules;
    }


    /**
     * Removes the actions marked as deleted from the given actions configuration.
     *
     * @param array $actionsConfiguration
     * @param boolean $totalNegation
     *
     * @return array
     */
    private function filterRemovedActions(array $actionsConfiguration, $totalNegation)
    {
        //si se encontro '!' hay una negacion total de todas las reglas estandard
        if ($totalNegation) {
            $removedActions = array_values($this->defaultRulesProperties);
        } else {
            // if the name of the action starts with a '!' dash, remove it
            $removedActions = array_filter($actionsConfiguration, function ($action) {
                return '!' === $action['code']{0};
            });
        }

        if (empty($removedActions)) {
            return $actionsConfiguration;
        }

        $tmpRemovedActions = array();
        foreach ($removedActions as $removedAction) {
            $tmpRemovedActions[$removedAction['code']] = $removedAction['code'];
        }
        $tmpRemovedActions['!'] = '!';

        $removedActions = $tmpRemovedActions;

        return array_filter($actionsConfiguration, function ($action) use ($removedActions) {
            // e.g. '!search' action name removes both '!search' and 'search' (if exists)
            return !array_key_exists($action['code'], $removedActions)
            && !array_key_exists('!' . $action['code'], $removedActions)
            && !array_key_exists($action['code'], $removedActions);
        });
    }


}
